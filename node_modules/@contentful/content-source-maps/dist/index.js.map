{"version":3,"file":"index.js","sources":["../../../node_modules/@vercel/stega/dist/index.mjs","../src/encode.ts","../../../node_modules/foreach/index.js","../../../node_modules/json-pointer/index.js","../src/richText.ts","../src/utils.ts","../src/graphql/encodeGraphQLResponse.ts","../src/rest/encodeCPAResponse.ts"],"sourcesContent":["var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","import {\n  vercelStegaCombine,\n  vercelStegaDecode,\n  vercelStegaEncode,\n  vercelStegaSplit,\n} from '@vercel/stega';\n\nimport type { SourceMapMetadata } from './types.js';\n\nexport function combine(text: string, metadata: SourceMapMetadata): string {\n  return vercelStegaCombine(text, metadata);\n}\n\nexport function encode(metadata: SourceMapMetadata): string {\n  return vercelStegaEncode(metadata);\n}\n\nexport function decode(text: string): SourceMapMetadata | undefined {\n  return vercelStegaDecode(text);\n}\n\nexport function splitEncoding(text: string): {\n  /** The original string with encoded substring removed */\n  cleaned: string;\n  /** The encoded substring from the original string */\n  encoded: string;\n} {\n  return vercelStegaSplit(text);\n}\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\nvar each = require('foreach');\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (typeof tok !== 'string' && typeof tok !== 'number') {\n          tok = String(tok)\n        }\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n","import type { Block, Inline, Node } from '@contentful/rich-text-types';\nimport { get, set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport type { CPAMappings, GraphQLMappings, SourceMapMetadata } from './types.js';\n\nexport const encodeRichTextValue = ({\n  pointer,\n  mappings,\n  data,\n  hiddenStrings,\n}: {\n  pointer: string;\n  mappings: CPAMappings | GraphQLMappings;\n  data: Node;\n  hiddenStrings: SourceMapMetadata;\n}) => {\n  const source = mappings[pointer];\n\n  // Only proceed with mapping if we have a valid source\n  if (source) {\n    // We can now safely delete the original pointer as we've preserved the source\n    delete mappings[pointer];\n\n    const textNodes = findRichTextNodes(data, pointer);\n    for (const textNode of textNodes) {\n      mappings[textNode] = source;\n      const currentTextNodeValue = get(data, textNode);\n      const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n      set(data, textNode, encodedValue);\n    }\n  } else {\n    // If there's no source mapping, just encode the text nodes without creating mappings\n    const textNodes = findRichTextNodes(data, pointer);\n    for (const textNode of textNodes) {\n      const currentTextNodeValue = get(data, textNode);\n      const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n      set(data, textNode, encodedValue);\n    }\n  }\n};\n\nfunction isNode(node: Node): node is Block | Inline {\n  return 'content' in node && !!node.content;\n}\n\nconst findRichTextNodes = (data: Node, currentPath = ''): string[] => {\n  const textNodes = [];\n  const node = get(data, currentPath);\n\n  if (isNode(node)) {\n    for (let i = 0; i < node.content.length; i++) {\n      if (node.content[i].nodeType === 'text') {\n        textNodes.push(`${currentPath}/content/${i}/value`);\n      } else {\n        textNodes.push(...findRichTextNodes(data, `${currentPath}/content/${i}`));\n      }\n    }\n  }\n\n  return textNodes;\n};\n","import { set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport { encodeRichTextValue } from './richText.js';\nimport type {\n  CPAAsset,\n  CPAEntry,\n  CPAMappings,\n  CreateSourceMapParams,\n  FieldType,\n  GraphQLMappings,\n  GraphQLResponse,\n  SourceMapMetadata,\n  WidgetId,\n  WidgetNamespace,\n} from './types.js';\n\nexport const createSourceMapMetadata = ({\n  entityId,\n  entityType,\n  space,\n  environment,\n  field,\n  locale,\n  editorInterface,\n  fieldType,\n  targetOrigin,\n  platform,\n}: CreateSourceMapParams): SourceMapMetadata => {\n  const targetOriginUrl = targetOrigin || 'https://app.contentful.com';\n  const basePath = `${targetOriginUrl}/spaces/${space}/environments/${environment}`;\n  const entityRoute = entityType === 'Entry' ? 'entries' : 'assets';\n  const href = `${basePath}/${entityRoute}/${entityId}/?focusedField=${field}&focusedLocale=${locale}&source=vercel-content-link`;\n\n  const result: SourceMapMetadata = {\n    origin: 'contentful.com',\n    href,\n    contentful: {\n      editorInterface,\n      fieldType,\n    },\n  };\n\n  // If the user has specified a platform, we remove the fields that are not relevant to that platform\n  if (platform === 'vercel') {\n    delete result.contentful;\n  }\n\n  return result;\n};\n\nexport const isBuiltinNamespace = (namespace: WidgetNamespace) =>\n  ['builtin', 'sidebar-builtin', 'editor-builtin'].includes(namespace);\nexport const isSupportedWidget = (widgetId: WidgetId) => SUPPORTED_WIDGETS.includes(widgetId);\n\n/**\n * Clones the incoming element into a new one, to prevent modification on the original object\n * Hint: It uses the structuredClone which is only available in modern browsers,\n * for older one it uses the JSON.parse(JSON.stringify) hack.\n */\nexport function clone<T extends Record<string, unknown> | Array<unknown>>(incoming: T): T {\n  if (typeof structuredClone === 'function') {\n    return structuredClone(incoming);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(incoming));\n  } catch (err) {\n    console.warn('Failed to clone data:', incoming, err);\n    return incoming;\n  }\n}\n\nexport const SUPPORTED_WIDGETS: WidgetId[] = [\n  'singleLine',\n  'tagEditor',\n  'listInput',\n  'checkbox',\n  'richTextEditor',\n  'multipleLine',\n];\n\nexport function encodeField(\n  fieldType: FieldType,\n  currentValue: any,\n  hiddenStrings: SourceMapMetadata,\n  target: GraphQLResponse | CPAEntry | CPAAsset,\n  pointer: string,\n  mappings: CPAMappings | GraphQLMappings,\n  locale?: string,\n) {\n  // Determine the value based on locale (if provided)\n  const value = locale ? currentValue[locale] : currentValue;\n\n  // Process based on fieldType\n  switch (fieldType) {\n    case 'Symbol': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'Text': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'RichText': {\n      encodeRichTextValue({\n        pointer: '',\n        mappings,\n        data: value,\n        hiddenStrings,\n      });\n      break;\n    }\n\n    case 'Array': {\n      const encodedArray = value.map((item: unknown) => {\n        if (typeof item === 'string') {\n          return combine(item, hiddenStrings);\n        } else {\n          return item; // Return the item unchanged if it's not a string\n        }\n      });\n      set(target, pointer, encodedArray);\n      break;\n    }\n  }\n}\n","import { get, has } from 'json-pointer';\n\nimport type { CreateSourceMapParams } from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nexport const encodeGraphQLResponse = <TResponse extends { data: any; extensions: any }>(\n  originalGraphqlResponse: TResponse,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): TResponse => {\n  if (\n    !originalGraphqlResponse ||\n    !originalGraphqlResponse.extensions ||\n    !originalGraphqlResponse.extensions.contentSourceMaps\n  ) {\n    console.error(\n      'GraphQL response does not contain Content Source Maps information.',\n      originalGraphqlResponse,\n    );\n    return originalGraphqlResponse;\n  }\n  const modifiedGraphqlResponse = clone(originalGraphqlResponse);\n  const {\n    spaces,\n    environments,\n    editorInterfaces,\n    fields,\n    locales,\n    entries,\n    assets,\n    mappings,\n    fieldTypes,\n  } = modifiedGraphqlResponse.extensions.contentSourceMaps;\n  const target = modifiedGraphqlResponse;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n\n    const entity = 'entry' in source ? entries[source.entry] : assets[source.asset];\n    const entityType = 'entry' in source ? 'Entry' : 'Asset';\n\n    if (!entity) {\n      return modifiedGraphqlResponse;\n    }\n\n    const space = spaces[entity.space];\n    const environment = environments[entity.environment];\n    const entityId = entity.id;\n    const field = fields[source.field];\n    const locale = locales[source.locale];\n    const editorInterface = editorInterfaces[source.editorInterface];\n    const fieldType = fieldTypes[source.fieldType];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    if (has(target, pointer)) {\n      const currentValue = get(target, pointer);\n\n      if (currentValue !== null) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, pointer, mappings);\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n  return modifiedGraphqlResponse;\n};\n","import { get, has } from 'json-pointer';\n\nimport type {\n  CPAEntry,\n  CPAEntryCollection,\n  EditorInterfaceSource,\n  FieldType,\n  CreateSourceMapParams,\n  CPAAsset,\n} from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nconst applyEncoding = (\n  target: CPAEntry | CPAAsset,\n  fieldTypes: FieldType[],\n  editorInterfaces: EditorInterfaceSource[],\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n) => {\n  if (!target.fields) {\n    return;\n  }\n\n  const { contentSourceMaps } = target.sys;\n\n  // Skip if there are no source maps\n  // For example if an entry has only one unsupported field\n  if (!contentSourceMaps) {\n    return;\n  }\n\n  const { mappings } = contentSourceMaps;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n    const space = target.sys.space.sys.id;\n    const environment = target.sys.environment.sys.id;\n    const entityId = target.sys.id;\n    const entityType = target.sys.type;\n    const fieldType = fieldTypes[source.fieldType];\n    const editorInterface = editorInterfaces[source.editorInterface];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    const formattedPointer = pointer.startsWith('/') ? pointer : `/${pointer}`;\n\n    if (has(target, formattedPointer)) {\n      const currentValue = get(target, formattedPointer);\n      if (currentValue === null) {\n        return;\n      }\n      const fieldParts = formattedPointer.split('/'); // Split the pointer into parts\n      const field = fieldParts.pop(); // Get the last part, which is the field name\n      if (!field) {\n        console.error('Field name could not be extracted from the pointer', formattedPointer);\n        return;\n      }\n      const locale = target.sys.locale;\n\n      // Determine if we are dealing with multiple locale values in the response or just a single locale\n      if (locale) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, formattedPointer, mappings);\n      } else {\n        const locales = Object.keys(currentValue);\n        locales.forEach((locale) => {\n          const hiddenStrings = createSourceMapMetadata({\n            entityId,\n            entityType,\n            space,\n            environment,\n            field,\n            locale,\n            editorInterface,\n            fieldType,\n            targetOrigin,\n            platform,\n          });\n\n          encodeField(\n            fieldType,\n            currentValue,\n            hiddenStrings,\n            target,\n            `${formattedPointer}/${locale}`,\n            mappings,\n            locale,\n          );\n        });\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n};\n\nexport const encodeCPAResponse = (\n  CPAResponse: CPAEntry | CPAEntryCollection,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): CPAEntry | CPAEntryCollection => {\n  const modifiedCPAResponse = clone(\n    CPAResponse as unknown as Record<string, unknown>,\n  ) as unknown as CPAEntry | CPAEntryCollection;\n\n  // Entity collections\n  if (modifiedCPAResponse.sys && 'items' in (modifiedCPAResponse as CPAEntryCollection)) {\n    const collection = modifiedCPAResponse as CPAEntryCollection;\n    if (!collection.sys?.contentSourceMapsLookup) {\n      return collection;\n    }\n    const {\n      contentSourceMapsLookup: { fieldTypes, editorInterfaces },\n    } = collection.sys;\n    const { items, includes } = collection;\n\n    items.forEach((target) =>\n      applyEncoding(target, fieldTypes, editorInterfaces, targetOrigin, platform),\n    );\n    if (includes && includes.Entry) {\n      includes.Entry.forEach((entry) =>\n        applyEncoding(entry, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    if (includes && includes.Asset) {\n      includes.Asset.forEach((asset) =>\n        applyEncoding(asset, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    // Single entity\n  } else {\n    const entry = modifiedCPAResponse as CPAEntry;\n    if (!entry.sys.contentSourceMapsLookup) {\n      console.error('Content source maps lookup data is missing');\n      return entry;\n    }\n\n    applyEncoding(\n      entry,\n      entry.sys.contentSourceMapsLookup.fieldTypes,\n      entry.sys.contentSourceMapsLookup.editorInterfaces,\n      targetOrigin,\n      platform,\n    );\n  }\n\n  return modifiedCPAResponse;\n};\n"],"names":["s","c","u","m","E","e","r","n","o","I","T","C","x","g","S","f","G","h","A","p","d","a","l","_","combine","text","metadata","vercelStegaCombine","encode","vercelStegaEncode","decode","vercelStegaDecode","splitEncoding","vercelStegaSplit","hasOwn","toString","foreach","obj","fn","ctx","k","each","require$$0","jsonPointer","api","pointer","value","wrapped","name","refTokens","i","tok","nextTok","finalToken","parent","index","descend","results","iterator","type","next","cur","key","str","encodeRichTextValue","mappings","data","hiddenStrings","source","textNodes","findRichTextNodes","textNode","currentTextNodeValue","get","encodedValue","set","isNode","node","currentPath","createSourceMapMetadata","entityId","entityType","space","environment","field","locale","editorInterface","fieldType","targetOrigin","platform","result","isBuiltinNamespace","namespace","isSupportedWidget","widgetId","SUPPORTED_WIDGETS","clone","incoming","err","encodeField","currentValue","target","encodedArray","item","encodeGraphQLResponse","originalGraphqlResponse","modifiedGraphqlResponse","spaces","environments","editorInterfaces","fields","locales","entries","assets","fieldTypes","entity","has","applyEncoding","contentSourceMaps","formattedPointer","encodeCPAResponse","CPAResponse","_a","modifiedCPAResponse","collection","items","includes","entry","asset"],"mappings":"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","x_google_ignoreList":[0,2,3]}